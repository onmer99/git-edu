팀 버너스리의

HTTP는 요청메서드를 정의하여 주어진 리소스에 수행하길 원하는 행동을 나타냅니다.
이를 HTTP 동사라고 부르기도 합니다. 각각의 메서드는 서로 다른 의미를 구현하지만 일부 기능은 메서드 집합 간에 서로 공유하기도 합니다. 예를들면 응답 메서드는 안전하거나, 캐시가능하거나, 멱등성을 가질 수 있습니다.

안전성
HTTP 메서드가 서버의 상태를 바꾸지 않으면 그 메서드가 안전하다고 말합니다.
다른 말로 하면, 읽기 작업만 수행하는 메서드는 안전합니다.
흔히 쓰이는 HTTP 메서드 중에서는 GET, HEAD, OPTIONS가 안전합니다.
모든 안전한 메서드는 멱등성 또한 갖지만, 모든 멱등성을 지닌 메서드가 안전한 것은 아닙니다.
예컨대 PUT과 DELETE는 둘 다 멱등성을 가졌지만 안전하지는 않은 메서드입니다.

캐시가능
캐시 가능(cacheable) 한 응답은 캐시할 수 있는 HTTP 응답으로, 나중에 검색하고 사용하기 위해 저장하여 새 요청을 서버에 저장합니다. 모든 HTTP 응답을 캐시할 수 있는 것은 아니며, 캐시할 HTTP 응답에 대한 제약 조건은 다음과 같습니다.
GET 또는 HEAD 메서드는 요청에 사용된 메서드는 그 자체로 캐시 가능합니다. POST 또는 PATCH 요청에 대한 응답은 유효성이 표시되고 Content-Location 헤더가 설정된 경우 캐시될 수도 있지만 거의 구현되지 않았습니다. (예를 들어, Firefox는 [https://bugzilla.mozilla.org/show_bug.cgi?id=109553](https://bugzilla.mozilla.org/show_bug.cgi?id=109553) 에 따라 이를 지원하지 않습니다.) PUT 혹은 DELETE 다른 메서드는 캐시 가능하지 않고 그 결과 역시 캐시할 수 없습니다.
애플리케이션 캐싱에 의해 알려진 응답의 상태 코드는 캐시 가능한 것으로 간주됩니다. 200, 203, 204, 206, 300, 301, 404, 405, 410, 414, 501 상태 코드는 캐시 가능합니다.
응답에는 Cache-Control과 같은 캐싱을 방지하는 특정 헤더가 있습니다.
특정 URI에 대한 일부 캐시할 수 없는 요청/응답은 동일한 URI에서 이전에 캐시된 응답을 무효화할 수 있습니다. 예를 들어 pageX.html에 대한 PUT 요청은 동일한 URI에 대한 GET 혹은 HEAD 요청의 캐시를 무효화합니다.
요청 메서드와 응답 상태가 모두 캐시 가능한 경우 요청에 대한 응답을 캐시할 수 있습니다.

멱등성
동일한 요청을 한 번 보내는 것과 여러 번 연속으로 보내는 것이 같은 효과를 지니고, 서버의 상태도 동일하게 남을 때, 해당 HTTP 메서드가 멱등성을 가졌다고 말합니다.
다른 말로는, 멱등성 메서드에는 통계기록 등을 제외하면 어떠한 부수효과(side effect)도 존재해서는 안됩니다. 예를 들어, 서버는 모든 요청을 받은 시간과 함께 기록할 수 있습니다. 멱등성(Idempotency)는 클라이언트가 의도한 효과에만 적용됩니다. 예를 들어, POST 요청은 데이터를 서버로 보내려고 하거나, DELETE 요청은 서버에서 리소스를 삭제하려고 합니다.
safe 메서드는 PUT and DELETE와 마찬가지로 멱등적입니다. POST 메서드는 멱등성이 아닙니다.
멱등성을 따질 땐 실제 서버의 백엔드 상태만 보면 되며, 각 요청에서 반환하는 응답 코드는 다를 수 있습니다. 첫 번째 DELETE 요청이 200을 반환한다면, 그 이후는 아마 404를 반환할 것입니다. DELETE가 멱등성을 가진다는 것은, REST API에서 개발자는 DELETE 메서드를 사용해 "목록의 마지막 항목 제거" 기능을 구현해서는 안 된다는 것입니다.
다만, 서버는 메서드의 멱등성을 보장하지 않으며, 일부 애플리케이션은 잘못된 구현으로 멱등성 제약을 어길 수도 있습니다.
GET /pageX HTTP/1.1는 안전한(읽기 전용) 메서드이기 때문에 멱등성을 가집니다. 그 동안 서버의 데이터가 업데이트된 경우, 다음에 하는 호출은 클라이언트에 다른 데이터를 반환할 수 있습니다.
POST /add_row HTTP/1.1은 멱등성을 가지지 않습니다. 여러 번 호출되면 여러 행을 추가합니다.

GET
GET 메서드는 특정 리소스의 표시를 요청합니다. GET을 사용하는 요청은 오직 데이터를 받기만 합니다.
쿼리스트링(Query String)은 URL + ?+ 데이터이름=값 형태로 표현됩니다.
HEAD 메서드는 GET 메소드의 요청과 동일한 응답을 요구하지만, 응답 본문을 포함하지 않습니다.
HEAD 메서드를 사용하는 이유?
데이터 양이 줄어들기 때문에 빠르게 서버의 상태를 조회할 수 있다.
응답 헤더의 Content-Length 또한 동일하기 때문에 resource 양에 대한 조회만 할 때에는 HEAD method가 유용할 수 있다.
POST
POST 메서드는 특정 리소스에 엔티티를 제출할 때 쓰입니다. 이는 종종 서버의 상태의 변화나 부작용을 일으킵니다.
<form action="[http://catSaveTheWorld.com/search](http://catsavetheworld.com/search)" method="POST">
<input type="text" name="username">
<input type="password" name="password">
<button type="submit">로그인</button>
</form>
위 코드에서는 사용자가 입력한 사용자 이름(username)과 비밀번호(password)를 POST 방식으로 전송합니다. 이때, HTTP 요청 본문(body)에 데이터가 포함되어 전송되므로, URL에는 아무런 데이터가 포함되지 않습니다.

GET방식 활용 예: 데이터 조회 (즐겨찾기 기능!)
검색 기능: 사용자가 검색어를 입력하고 서버에서 검색어를 받아서 처리한 후, 검색 결과를 브라우저에 노출
페이지 이동: 브라우저에서 다른 페이지로 이동할 때
쿠키와 같은 작은 데이터 전송: 브라우저와 서버 간에 쿠키와 같은 작은 데이터 전송시

POST방식 활용 예:
회원가입, 로그인: 사용자가 입력한 회원 정보를 서버에 전송하여 회원가입 또는 로그인 처리
게시글 작성: 사용자가 입력한 게시글 내용을 서버에 전송하여 게시글을 작성
파일 업로드: 사용자가 업로드한 파일을 서버에 전송하여 저장

PUT
PUT 메서드는 목적 리소스 모든 현재 표시를 요청 payload로 바꿉니다.
DELETE
DELETE 메서드는 특정 리소스를 삭제합니다.
PATCH
PATCH 메서드는 리소스의 부분만을 수정하는 데 쓰입니다.

GET은 데이터를 조회하기 위해 사용되는 방식으로 데이터를 헤더에 추가하여 전송하는 방식입니다.
URL에 데이터가 노출되므로 보안적으로 중요한 데이터를 포함해서는 안됩니다.
POST는 데이터를 추가 또는 수정하기 위해 사용되는 방식으로 데이터를 바디에 추가하여 전송하는 방식입니다.
완전히 안전하다는 것은 아니지만 URL에 데이터가 노출되지 않아 GET 보다는 안전합니다.
